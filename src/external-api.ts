/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/players/register": {
    /**
     * Register A Player 
     * @description Register a new username with the game.
     */
    post: operations["register_a_player_players_register_post"];
    /**
     * Remove Player From Game 
     * @description Delete the user from the game.
     * Player will only send their auth_token and no other data and we will invalidate it.
     */
    delete: operations["remove_player_from_game_players_register_delete"];
  };
  "/players/": {
    /**
     * Get Player Info 
     * @description Verify your credentials are working properly. 
     * If you get back what you sent in, with no HTTP errors, you win!
     */
    get: operations["get_player_info_players__get"];
  };
  "/rounds": {
    /**
     * Start A Round Of Play 
     * @description Create a new round of play.
     * You need to have your basic auth header set in order to use this endpoint.
     */
    post: operations["start_a_round_of_play_rounds_post"];
  };
  "/rounds/{round}": {
    /**
     * Get Status Of Round 
     * @description Query for the current status of a round of play
     */
    get: operations["get_status_of_round_rounds__round__get"];
    /**
     * Cancel A Round 
     * @description Cancel a round, killing the round
     */
    delete: operations["cancel_a_round_rounds__round__delete"];
  };
  "/customers/": {
    /**
     * Get The First Customer 
     * @description Used for integration testing the endpoints
     */
    post: operations["get_the_first_customer_customers__post"];
  };
  "/users/": {
    /** Get The First User */
    post: operations["get_the_first_user_users__post"];
  };
  "/notify/{customer}/{user}": {
    /**
     * Get Status Of Notification 
     * @description Queries to see if the notification has been responded to by the user being background checked
     */
    get: operations["get_status_of_notification_notify__customer___user__get"];
    /**
     * Create A Notification 
     * @description Mimics sending an email to the human getting background checked.
     */
    post: operations["create_a_notification_notify__customer___user__post"];
  };
  "/notify/{notify_uuid}": {
    /**
     * Cancel A Notification 
     * @description Allows the player to attempt to cancel the notify if it is in flight
     */
    delete: operations["cancel_a_notification_notify__notify_uuid__delete"];
  };
  "/notify/report/{customer}/{user}": {
    /** Send Background Check Confirmations */
    post: operations["send_background_check_confirmations_notify_report__customer___user__post"];
  };
  "/search/{search_type}/{customer}/{user}": {
    /**
     * Get Status Of Search 
     * @description Get the status of the check, returns a GUID if the status is 'complete'
     */
    get: operations["get_status_of_search_search__search_type___customer___user__get"];
    /**
     * Start A Search 
     * @description Start a check with name: {user}
     */
    post: operations["start_a_search_search__search_type___customer___user__post"];
  };
  "/report": {
    /**
     * Get Round Report 
     * @description Get the report at the end of the round
     */
    get: operations["get_round_report_report_get"];
  };
  "/background-check/{customer}/{user}": {
    /**
     * Cancel A Background Check 
     * @description Send a request to cancel the background check
     */
    delete: operations["cancel_a_background_check_background_check__customer___user__delete"];
  };
  "/confirm": {
    /**
     * Confirm Endpoint 
     * @description Mocking out the client so we can test, needs to respond with the testing user that we make up during tests.
     * We can pass the username along in the header as a result.
     * When testing outside of pytest, the user defaults to test_user
     */
    post: operations["confirm_endpoint_confirm_post"];
  };
  "/background": {
    /**
     * Background Endpoint 
     * @description For testing, we want to respond with confirmed.
     * @todo-game we need to make this more resilient against bad client implementations that do non-standard shit.
     */
    post: operations["background_endpoint_background_post"];
  };
  "/complete": {
    /**
     * Complete Endpoint 
     * @description For testing, we want to respond with confirmed.
     * @todo-game we need to make this more resilient against bad client implementations that do non-standard shit.
     */
    post: operations["complete_endpoint_complete_post"];
  };
  "/": {
    /**
     * Welcome 
     * @description Welcome to the game.
     */
    get: operations["welcome__get"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** Background */
    Background: {
      /** Customer */
      customer?: string;
      /** User */
      user?: string;
      /** Action */
      action?: string;
    };
    /** Customer */
    Customer: {
      /** Customer */
      customer: string;
    };
    /** CustomerReport */
    CustomerReport: {
      /** Complete */
      complete?: number;
      /** Complete Percent */
      complete_percent?: number;
      /** Expected */
      expected?: number;
      /** Failed */
      failed?: number;
      /** Failed Percent */
      failed_percent?: number;
      /** Processed */
      processed?: number;
      /** Processed Percent */
      processed_percent?: number;
      /** Cancelled */
      cancelled?: number;
      /** Cancelled Percent */
      cancelled_percent?: number;
      status?: components["schemas"]["StatusEnum"];
      /** Users Calculated */
      users_calculated?: (string)[];
      /** Users Sent */
      users_sent?: (string)[];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: (components["schemas"]["ValidationError"])[];
    };
    /** Message */
    Message: {
      /**
       * Message 
       * @default Welcome to the game.
       */
      message?: string;
    };
    /** NotifyReport */
    NotifyReport: {
      /** Notification */
      notification: string;
      /** Ssn */
      ssn: string;
      /** Social */
      social: string;
      /** Credit */
      credit: string;
    };
    /** Player */
    Player: {
      /** Username */
      username: string;
      /** Auth Token */
      auth_token?: string;
    };
    /** PlayerRegister */
    PlayerRegister: {
      /** Username */
      username: string;
    };
    /** Round */
    Round: {
      /** Path */
      path: string;
      /** Level */
      level: number;
    };
    /** RoundReport */
    RoundReport: {
      /** Customers */
      customers: {
        [key: string]: components["schemas"]["CustomerReport"] | undefined;
      };
      totals?: components["schemas"]["CustomerReport"];
      /** Rounds */
      rounds?: {
        [key: string]: number | undefined;
      };
      /** Next Level */
      next_level?: number;
    };
    /** RoundStatus */
    RoundStatus: {
      /** Path */
      path: string;
      /** Level */
      level: number;
      status: components["schemas"]["StatusEnum"];
      /** Round */
      round?: string;
    };
    /**
     * SearchesEnum 
     * @description An enumeration. 
     * @enum {string}
     */
    SearchesEnum: "notification" | "ssn" | "credit" | "social";
    /** Status */
    Status: {
      status: components["schemas"]["StatusEnum"];
    };
    /** StatusConfirmation */
    StatusConfirmation: {
      status: components["schemas"]["StatusEnum"];
      /** Confirmation */
      confirmation?: string;
    };
    /**
     * StatusEnum 
     * @description An enumeration. 
     * @enum {string}
     */
    StatusEnum: "created" | "started" | "pending" | "running" | "rejected" | "cancelled" | "failed" | "complete";
    /**
     * User 
     * @description User Model: contains a customer ID as 'customer' and user ID as 'user'
     */
    User: {
      /** Customer */
      customer: string;
      /** User */
      user: string;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  register_a_player_players_register_post: {
    /**
     * Register A Player 
     * @description Register a new username with the game.
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PlayerRegister"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Player"];
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  remove_player_from_game_players_register_delete: {
    /**
     * Remove Player From Game 
     * @description Delete the user from the game.
     * Player will only send their auth_token and no other data and we will invalidate it.
     */
    responses: {
      /** @description Successful Response */
      204: never;
      /** @description Not found */
      404: never;
    };
  };
  get_player_info_players__get: {
    /**
     * Get Player Info 
     * @description Verify your credentials are working properly. 
     * If you get back what you sent in, with no HTTP errors, you win!
     */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Player"];
        };
      };
      /** @description Not found */
      404: never;
    };
  };
  start_a_round_of_play_rounds_post: {
    /**
     * Start A Round Of Play 
     * @description Create a new round of play.
     * You need to have your basic auth header set in order to use this endpoint.
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Round"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_status_of_round_rounds__round__get: {
    /**
     * Get Status Of Round 
     * @description Query for the current status of a round of play
     */
    parameters: {
      path: {
        round: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["RoundStatus"];
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  cancel_a_round_rounds__round__delete: {
    /**
     * Cancel A Round 
     * @description Cancel a round, killing the round
     */
    parameters: {
      path: {
        round: string;
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": components["schemas"]["RoundStatus"];
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_the_first_customer_customers__post: {
    /**
     * Get The First Customer 
     * @description Used for integration testing the endpoints
     */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Customer"];
        };
      };
      /** @description Not found */
      404: never;
    };
  };
  get_the_first_user_users__post: {
    /** Get The First User */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["User"];
        };
      };
      /** @description Not found */
      404: never;
    };
  };
  get_status_of_notification_notify__customer___user__get: {
    /**
     * Get Status Of Notification 
     * @description Queries to see if the notification has been responded to by the user being background checked
     */
    parameters: {
      path: {
        customer: string;
        user: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StatusConfirmation"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  create_a_notification_notify__customer___user__post: {
    /**
     * Create A Notification 
     * @description Mimics sending an email to the human getting background checked.
     */
    parameters: {
      path: {
        customer: string;
        user: string;
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["Status"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  cancel_a_notification_notify__notify_uuid__delete: {
    /**
     * Cancel A Notification 
     * @description Allows the player to attempt to cancel the notify if it is in flight
     */
    parameters: {
      query: {
        customer: string;
        user: string;
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": components["schemas"]["StatusConfirmation"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  send_background_check_confirmations_notify_report__customer___user__post: {
    /** Send Background Check Confirmations */
    parameters: {
      path: {
        customer: string;
        user: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["NotifyReport"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_status_of_search_search__search_type___customer___user__get: {
    /**
     * Get Status Of Search 
     * @description Get the status of the check, returns a GUID if the status is 'complete'
     */
    parameters: {
      path: {
        search_type: string;
        customer: string;
        user: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StatusConfirmation"];
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  start_a_search_search__search_type___customer___user__post: {
    /**
     * Start A Search 
     * @description Start a check with name: {user}
     */
    parameters: {
      path: {
        search_type: components["schemas"]["SearchesEnum"];
        customer: string;
        user: string;
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["Status"];
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_round_report_report_get: {
    /**
     * Get Round Report 
     * @description Get the report at the end of the round
     */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["RoundReport"];
        };
      };
    };
  };
  cancel_a_background_check_background_check__customer___user__delete: {
    /**
     * Cancel A Background Check 
     * @description Send a request to cancel the background check
     */
    parameters: {
      path: {
        customer: string;
        user: string;
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  confirm_endpoint_confirm_post: {
    /**
     * Confirm Endpoint 
     * @description Mocking out the client so we can test, needs to respond with the testing user that we make up during tests.
     * We can pass the username along in the header as a result.
     * When testing outside of pytest, the user defaults to test_user
     */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Not found */
      404: never;
    };
  };
  background_endpoint_background_post: {
    /**
     * Background Endpoint 
     * @description For testing, we want to respond with confirmed.
     * @todo-game we need to make this more resilient against bad client implementations that do non-standard shit.
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Background"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Not found */
      404: never;
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  complete_endpoint_complete_post: {
    /**
     * Complete Endpoint 
     * @description For testing, we want to respond with confirmed.
     * @todo-game we need to make this more resilient against bad client implementations that do non-standard shit.
     */
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Not found */
      404: never;
    };
  };
  welcome__get: {
    /**
     * Welcome 
     * @description Welcome to the game.
     */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Message"];
        };
      };
    };
  };
}
